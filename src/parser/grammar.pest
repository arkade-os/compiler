// Whitespace and comments are silently consumed
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n" }

// Main entry point - must consume the entire input
main = { SOI ~ contract ~ EOI }

// Contract definition with strict structure and optional options block
contract = {
    options_block? ~
    "contract" ~ identifier ~
    "(" ~ param_list ~ ")" ~
    "{" ~ function* ~ "}"
}

// Options block for contract configuration
options_block = {
    "options" ~ "{" ~ (option_setting ~ ";")* ~ "}"
}

// Option setting with assignment
option_setting = {
    identifier ~ "=" ~ (number_literal | identifier | string_literal)
}

// Parameter list with proper comma separation
param_list = {
    (parameter ~ ("," ~ parameter)*)?
}

// Parameter definition
parameter = { data_type ~ identifier }

// Supported data types - atomic rule to prevent partial matches
// Note: longer types must come before shorter prefixes (bytes32/bytes20 before bytes)
data_type = @{ "pubkey" | "signature" | "bytes32" | "bytes20" | "bytes" | "asset" | "int" | "bool" }

// Function definition with strict structure
function = {
    "function" ~ identifier ~
    "(" ~ param_list ~ ")" ~
    function_modifier? ~
    "{" ~ (require_stmt | let_binding | function_call_stmt | variable_declaration)* ~ "}"
}

// Function modifier (internal, etc.)
function_modifier = { "internal" }

// Require statement
require_stmt = {
    "require" ~ "(" ~ complex_expression ~ ("," ~ string_literal)? ~ ")" ~ ";"
}

// Let binding: let identifier = expression;
let_binding = {
    "let" ~ identifier ~ "=" ~ complex_expression ~ ";"
}

// Function call statement
function_call_stmt = {
    identifier ~ "(" ~ (complex_expression ~ ("," ~ complex_expression)*)? ~ ")" ~ ";"
}

// Variable declaration
variable_declaration = {
    data_type ~ identifier ~ "=" ~ complex_expression ~ ";"
}

// Complex expression types — ordered by specificity (most specific first)
// PEG ordered choice: first matching alternative wins
complex_expression = _{
    check_sig_from_stack |
    check_sig |
    check_multisig |
    time_comparison |
    hash_comparison |
    asset_lookup_comparison |
    group_property_comparison |
    property_comparison |
    identifier_comparison |
    binary_operation |
    asset_lookup |
    asset_group_access |
    p2tr_constructor |
    tx_property_access |
    this_property_access |
    function_call |
    identifier |
    number_literal |
    array_literal
}

// ─── Asset Lookups ─────────────────────────────────────────────────────────────

// Asset lookup on inputs/outputs: tx.inputs[i].assets.lookup(assetId)
asset_lookup = {
    "tx" ~ "." ~ asset_lookup_source ~ array_access ~ "." ~ "assets" ~ "." ~ "lookup" ~ "(" ~ identifier ~ ")"
}

// Source of asset lookup (inputs or outputs)
asset_lookup_source = { "inputs" | "outputs" }

// Asset lookup comparison: asset_lookup op expression
// Handles: tx.inputs[0].assets.lookup(id) >= 0
//          tx.outputs[0].assets.lookup(id) >= tx.inputs[0].assets.lookup(id)
//          tx.outputs[0].assets.lookup(id) >= tx.inputs[0].assets.lookup(id) + amount
asset_lookup_comparison = {
    asset_lookup ~ binary_operator ~ (asset_lookup_arith_expr | asset_lookup | identifier | number_literal)
}

// Arithmetic expression in asset lookup context (e.g., lookup + amount)
asset_lookup_arith_expr = {
    (asset_lookup | identifier | number_literal) ~ ("+" | "-" | "*" | "/") ~ (asset_lookup | identifier | number_literal)
}

// ─── Asset Groups ──────────────────────────────────────────────────────────────

// Asset group access: tx.assetGroups.find(id), tx.assetGroups.length,
// tx.assetGroups[k].sumInputs, etc.
asset_group_access = {
    "tx" ~ "." ~ "assetGroups" ~ (
        "." ~ "find" ~ "(" ~ identifier ~ ")" |
        "." ~ "length" |
        array_access ~ "." ~ group_property
    )
}

// Group property names — atomic to prevent partial matches
group_property = @{
    "sumInputs" | "sumOutputs" | "delta" | "control" | "metadataHash" | "assetId" | "isFresh"
}

// Group property comparison: variable.property op expression
// Matches patterns like: tokenGroup.delta == amount, tokenGroup.sumOutputs >= 0
group_property_comparison = {
    identifier ~ "." ~ group_property ~ binary_operator ~ (asset_lookup | asset_group_access | identifier | number_literal)
}

// ─── Standard Comparisons ──────────────────────────────────────────────────────

// Time comparison (tx.time >= timelock)
time_comparison = {
    "tx.time" ~ ">=" ~ identifier
}

// Identifier comparison (identifier operator identifier)
identifier_comparison = {
    identifier ~ binary_operator ~ identifier
}

// Property comparison (property_access operator expression)
property_comparison = {
    (tx_property_access | this_property_access) ~ binary_operator ~ (asset_lookup | identifier | number_literal | tx_property_access | this_property_access | p2tr_constructor)
}

// Hash comparison (sha256(preimage) == hash)
hash_comparison = {
    sha256_func ~ "==" ~ identifier
}

// Binary operations between literals or identifiers
binary_operation = {
    (number_literal ~ binary_operator ~ (identifier | number_literal)) |
    (identifier ~ binary_operator ~ (identifier | number_literal))
}

binary_operator = { "==" | "<=" | ">=" | "!=" | "<" | ">" | "+" | "-" | "*" | "/" }

// ─── P2TR Constructor ──────────────────────────────────────────────────────────

// P2TR constructor
p2tr_constructor = {
    "new" ~ "P2TR" ~ "(" ~ p2tr_constructor_args ~ ")"
}

// Arguments for P2TR constructor
p2tr_constructor_args = {
    complex_expression ~ ("," ~ complex_expression)*
}

// ─── Transaction Property Access ───────────────────────────────────────────────

// Transaction property access with special handling
tx_property_access = {
    "tx" ~ "." ~ (
        // Input.current syntax - first-class support for current input introspection
        ("input" ~ "." ~ "current" ~ ("." ~ identifier)*) |
        // Standard property access
        (tx_property_part ~ (array_access | ("." ~ tx_property_part))*)
    )
}

// This property access
this_property_access = {
    "this" ~ "." ~ this_property
}

// This properties
this_property = {
    "activeInputIndex" | "activeBytecode"
}

// Property part with various access types
tx_property_part = {
    tx_special_property | tx_method_call | identifier
}

// Special properties that have specific meaning
tx_special_property = {
    "time" | "inputs" | "outputs" | "version" | "locktime" | "currentInput" | "assetGroups"
}

// Array access with index
array_access = {
    "[" ~ (number_literal | identifier | this_property_access | tx_special_property) ~ "]"
}

// Method call
tx_method_call = {
    identifier ~ "(" ~ ")"
}

// Array literal
array_literal = {
    "[" ~ complex_expression ~ ("," ~ complex_expression)* ~ "]"
}

// Function call
function_call = {
    identifier ~ "(" ~ (complex_expression ~ ("," ~ complex_expression)*)? ~ ")"
}

// ─── Cryptographic Primitives ──────────────────────────────────────────────────

// CheckSig expression
check_sig = {
    "checkSig" ~ "(" ~ identifier ~ "," ~ identifier ~ ")"
}

// CheckSigFromStack expression
check_sig_from_stack = {
    "checkSigFromStack" ~ "(" ~ identifier ~ "," ~ identifier ~ "," ~ identifier ~ ")"
}

// CheckMultisig expression
check_multisig = {
    "checkMultisig" ~ "(" ~ array ~ "," ~ array ~ ")"
}

// Array of identifiers
array = {
    "[" ~ identifier ~ ("," ~ identifier)* ~ "]"
}

// SHA256 function
sha256_func = {
    "sha256" ~ "(" ~ complex_expression ~ ")"
}

// ─── Terminals ─────────────────────────────────────────────────────────────────

// Identifiers must start with a letter and can contain letters, numbers, and underscores
identifier = @{
    ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")*
}

// Number literals are sequences of digits
number_literal = @{
    ASCII_DIGIT+
}

// String literals are sequences of characters enclosed in double quotes
string_literal = @{
    "\"" ~ (!"\"" ~ ANY)* ~ "\""
}
