// Whitespace and comments are silently consumed
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n" }

// Main entry point - must consume the entire input
main = { SOI ~ contract ~ EOI }

// Contract definition with strict structure and optional options block
contract = { 
    options_block? ~
    "contract" ~ identifier ~ 
    "(" ~ param_list ~ ")" ~ 
    "{" ~ function* ~ "}" 
}

// Options block for contract configuration
options_block = {
    "options" ~ "{" ~ (option_setting ~ ";")* ~ "}"
}

// Option setting with assignment
option_setting = {
    identifier ~ "=" ~ (number_literal | identifier | string_literal)
}

// Parameter list with proper comma separation
param_list = { 
    (parameter ~ ("," ~ parameter)*)? 
}

// Parameter definition
parameter = { data_type ~ identifier }

// Supported data types - atomic rule to prevent partial matches
data_type = @{ "pubkey" | "signature" | "bytes" | "bytes20" | "bytes32" | "asset" | "int" | "int32" | "int64" | "bool" }

// Function definition with strict structure
function = { 
    "function" ~ identifier ~ 
    "(" ~ param_list ~ ")" ~ 
    function_modifier? ~
    "{" ~ (require_stmt | function_call_stmt | variable_declaration)* ~ "}" 
}

// Function modifier (internal, etc.)
function_modifier = { "internal" }

// Require statement
require_stmt = { 
    "require" ~ "(" ~ complex_expression ~ ("," ~ string_literal)? ~ ")" ~ ";" 
}

// Function call statement
function_call_stmt = {
    identifier ~ "(" ~ (complex_expression ~ ("," ~ complex_expression)*)? ~ ")" ~ ";"
}

// Variable declaration
variable_declaration = {
    data_type ~ identifier ~ "=" ~ complex_expression ~ ";"
}

// Complex expression types
complex_expression = _{ 
    check_sig_from_stack |
    check_sig | 
    check_multisig | 
    time_comparison |
    identifier_comparison |
    hash_comparison |
    property_comparison |
    binary_operation |
    p2tr_constructor |
    tx_property_access |
    this_property_access |
    function_call |
    identifier |
    number_literal |
    array_literal |
    // New Elements opcodes
    streaming_sha256 |
    tx_introspection |
    arithmetic64 |
    conversion |
    crypto_op
}

// Time comparison (tx.time >= timelock)
time_comparison = {
    "tx.time" ~ ">=" ~ identifier
}

// Identifier comparison (identifier operator identifier)
identifier_comparison = {
    identifier ~ binary_operator ~ identifier
}

// Property comparison (property_access operator expression)
property_comparison = {
    (tx_property_access | this_property_access) ~ binary_operator ~ (identifier | number_literal | tx_property_access | this_property_access | p2tr_constructor)
}

// Hash comparison (sha256(preimage) == hash)
hash_comparison = {
    sha256_func ~ "==" ~ identifier
}

// Binary operations between literals or identifiers
binary_operation = {
    (number_literal ~ binary_operator ~ (identifier | number_literal)) |
    (identifier ~ binary_operator ~ (identifier | number_literal))
}

binary_operator = { "==" | "<" | ">" | ">=" | "<=" | "!=" | "+" | "-" | "*" | "/" }

// P2TR constructor
p2tr_constructor = {
    "new" ~ "P2TR" ~ "(" ~ p2tr_constructor_args ~ ")"
}

// Arguments for P2TR constructor
p2tr_constructor_args = {
    complex_expression ~ ("," ~ complex_expression)*
}

// Transaction property access with special handling
tx_property_access = {
    "tx" ~ "." ~ (
        // Standard property access
        (tx_property_part ~ (array_access | ("." ~ tx_property_part))*)
    )
}

// This property access
this_property_access = {
    "this" ~ "." ~ this_property
}

// This properties
this_property = {
    "activeInputIndex" | "activeBytecode"
}

// Property part with various access types
tx_property_part = {
    tx_special_property | tx_method_call | identifier
}

// Special properties that have specific meaning
tx_special_property = { 
    "time" | "inputs" | "outputs" | "version" | "locktime" | "currentInput"
}

// Array access with index
array_access = {
    "[" ~ (number_literal | identifier | this_property_access | tx_special_property) ~ "]"
}

// Method call
tx_method_call = {
    identifier ~ "(" ~ ")"
}

// Array literal
array_literal = {
    "[" ~ complex_expression ~ ("," ~ complex_expression)* ~ "]"
}

// Function call
function_call = {
    identifier ~ "(" ~ (complex_expression ~ ("," ~ complex_expression)*)? ~ ")"
}

// CheckSig expression
check_sig = { 
    "checkSig" ~ "(" ~ identifier ~ "," ~ identifier ~ ")" 
}

// CheckSigFromStack expression
check_sig_from_stack = {
    "checkSigFromStack" ~ "(" ~ identifier ~ "," ~ identifier ~ "," ~ identifier ~ ")"
}

// CheckMultisig expression
check_multisig = { 
    "checkMultisig" ~ "(" ~ array ~ "," ~ array ~ ")" 
}

// Array of identifiers
array = { 
    "[" ~ identifier ~ ("," ~ identifier)* ~ "]" 
}

// SHA256 function
sha256_func = {
    "sha256" ~ "(" ~ complex_expression ~ ")"
}

// Identifiers must start with a letter and can contain letters, numbers, and underscores
identifier = @{ 
    ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* 
}

// Number literals are sequences of digits
number_literal = @{ 
    ASCII_DIGIT+ 
}

// String literals are sequences of characters enclosed in double quotes
string_literal = @{
    "\"" ~ (!"\"" ~ ANY)* ~ "\""
}

// Streaming SHA256 operations
streaming_sha256 = {
    sha256_initialize |
    sha256_update |
    sha256_finalize |
    sha256_large_data
}

sha256_initialize = {
    "sha256Initialize" ~ "(" ~ complex_expression ~ ")"
}

sha256_update = {
    "sha256Update" ~ "(" ~ complex_expression ~ "," ~ complex_expression ~ ")"
}

sha256_finalize = {
    "sha256Finalize" ~ "(" ~ complex_expression ~ "," ~ complex_expression ~ ")"
}

sha256_large_data = {
    "sha256LargeData" ~ "(" ~ complex_expression ~ ")"
}

// Transaction introspection operations
tx_introspection = {
    // Input introspection
    "tx.input" ~ "[" ~ complex_expression ~ "]" ~ "." ~ tx_input_property |
    "tx.currentInput" ~ "." ~ tx_input_property |
    "tx.currentInputIndex" |
    
    // Output introspection
    "tx.output" ~ "[" ~ complex_expression ~ "]" ~ "." ~ tx_output_property |
    
    // Transaction introspection
    "tx.version" |
    "tx.locktime" |
    "tx.numInputs" |
    "tx.numOutputs" |
    "tx.weight"
}

tx_input_property = {
    "outpoint" |
    "asset" |
    "value" |
    "scriptPubKey" |
    "sequence" |
    "issuance"
}

tx_output_property = {
    "asset" |
    "value" |
    "nonce" |
    "scriptPubKey"
}

// 64-bit arithmetic operations
arithmetic64 = {
    add64 |
    sub64 |
    mul64 |
    div64 |
    neg64 |
    less_than64 |
    less_than_or_equal64 |
    greater_than64 |
    greater_than_or_equal64
}

add64 = {
    "add64" ~ "(" ~ complex_expression ~ "," ~ complex_expression ~ ")"
}

sub64 = {
    "sub64" ~ "(" ~ complex_expression ~ "," ~ complex_expression ~ ")"
}

mul64 = {
    "mul64" ~ "(" ~ complex_expression ~ "," ~ complex_expression ~ ")"
}

div64 = {
    "div64" ~ "(" ~ complex_expression ~ "," ~ complex_expression ~ ")"
}

neg64 = {
    "neg64" ~ "(" ~ complex_expression ~ ")"
}

less_than64 = {
    "lessThan64" ~ "(" ~ complex_expression ~ "," ~ complex_expression ~ ")"
}

less_than_or_equal64 = {
    "lessThanOrEqual64" ~ "(" ~ complex_expression ~ "," ~ complex_expression ~ ")"
}

greater_than64 = {
    "greaterThan64" ~ "(" ~ complex_expression ~ "," ~ complex_expression ~ ")"
}

greater_than_or_equal64 = {
    "greaterThanOrEqual64" ~ "(" ~ complex_expression ~ "," ~ complex_expression ~ ")"
}

// Conversion operations
conversion = {
    scriptnum_to_le64 |
    le64_to_scriptnum |
    le32_to_le64
}

scriptnum_to_le64 = {
    "scriptNumToLE64" ~ "(" ~ complex_expression ~ ")"
}

le64_to_scriptnum = {
    "le64ToScriptNum" ~ "(" ~ complex_expression ~ ")"
}

le32_to_le64 = {
    "le32ToLE64" ~ "(" ~ complex_expression ~ ")"
}

// Crypto operations
crypto_op = {
    ecmulscalar_verify |
    tweak_verify |
    checksig_from_stack
}

ecmulscalar_verify = {
    "ecmulscalarVerify" ~ "(" ~ complex_expression ~ "," ~ complex_expression ~ "," ~ complex_expression ~ ")"
}

tweak_verify = {
    "tweakVerify" ~ "(" ~ complex_expression ~ "," ~ complex_expression ~ "," ~ complex_expression ~ ")"
}

checksig_from_stack = {
    "checkSigFromStack" ~ "(" ~ complex_expression ~ "," ~ complex_expression ~ "," ~ complex_expression ~ ")"
}
