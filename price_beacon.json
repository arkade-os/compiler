{
  "contractName": "PriceBeacon",
  "constructorInputs": [
    {
      "name": "priceAssetId_txid",
      "type": "bytes32"
    },
    {
      "name": "priceAssetId_gidx",
      "type": "int"
    },
    {
      "name": "oraclePk",
      "type": "pubkey"
    }
  ],
  "functions": [
    {
      "name": "passthrough",
      "functionInputs": [],
      "serverVariant": true,
      "require": [
        {
          "type": "comparison"
        },
        {
          "type": "assetCheck"
        },
        {
          "type": "serverSignature"
        }
      ],
      "asm": [
        "0",
        "OP_INSPECTOUTPUTSCRIPTPUBKEY",
        "<new PriceBeacon(priceAssetId, oraclePk)>",
        "OP_EQUAL",
        "<tx.inputs[0].assets.lookup(priceAssetId)>",
        "0",
        "<priceAssetId_txid>",
        "<priceAssetId_gidx>",
        "OP_INSPECTOUTASSETLOOKUP",
        "OP_DUP",
        "OP_1NEGATE",
        "OP_EQUAL",
        "OP_NOT",
        "OP_VERIFY",
        "<currentPrice>",
        "OP_GREATERTHANOREQUAL64",
        "OP_VERIFY",
        "<SERVER_KEY>",
        "<serverSig>",
        "OP_CHECKSIG"
      ]
    },
    {
      "name": "passthrough",
      "functionInputs": [],
      "serverVariant": false,
      "require": [
        {
          "type": "nOfNMultisig",
          "message": "0-of-0 signatures required (introspection fallback)"
        },
        {
          "type": "older",
          "message": "Exit timelock of 144 blocks"
        }
      ],
      "asm": [
        "144",
        "OP_CHECKSEQUENCEVERIFY",
        "OP_DROP"
      ]
    },
    {
      "name": "update",
      "functionInputs": [
        {
          "name": "oracleSig",
          "type": "signature"
        },
        {
          "name": "newPrice",
          "type": "int"
        }
      ],
      "serverVariant": true,
      "require": [
        {
          "type": "signature"
        },
        {
          "type": "comparison"
        },
        {
          "type": "comparison"
        },
        {
          "type": "assetCheck"
        },
        {
          "type": "serverSignature"
        }
      ],
      "asm": [
        "<oraclePk>",
        "<oracleSig>",
        "OP_CHECKSIG",
        "<newPrice>",
        "0",
        "OP_GREATERTHAN",
        "0",
        "OP_INSPECTOUTPUTSCRIPTPUBKEY",
        "<new PriceBeacon(priceAssetId, oraclePk)>",
        "OP_EQUAL",
        "0",
        "<priceAssetId_txid>",
        "<priceAssetId_gidx>",
        "OP_INSPECTOUTASSETLOOKUP",
        "OP_DUP",
        "OP_1NEGATE",
        "OP_EQUAL",
        "OP_NOT",
        "OP_VERIFY",
        "<newPrice>",
        "OP_EQUAL",
        "OP_VERIFY",
        "<SERVER_KEY>",
        "<serverSig>",
        "OP_CHECKSIG"
      ]
    },
    {
      "name": "update",
      "functionInputs": [
        {
          "name": "oracleSig",
          "type": "signature"
        },
        {
          "name": "newPrice",
          "type": "int"
        }
      ],
      "serverVariant": false,
      "require": [
        {
          "type": "nOfNMultisig",
          "message": "0-of-0 signatures required (introspection fallback)"
        },
        {
          "type": "older",
          "message": "Exit timelock of 144 blocks"
        }
      ],
      "asm": [
        "144",
        "OP_CHECKSEQUENCEVERIFY",
        "OP_DROP"
      ]
    },
    {
      "name": "migrate",
      "functionInputs": [
        {
          "name": "oracleSig",
          "type": "signature"
        },
        {
          "name": "newOraclePk",
          "type": "pubkey"
        }
      ],
      "serverVariant": true,
      "require": [
        {
          "type": "signature"
        },
        {
          "type": "comparison"
        },
        {
          "type": "assetCheck"
        },
        {
          "type": "serverSignature"
        }
      ],
      "asm": [
        "<oraclePk>",
        "<oracleSig>",
        "OP_CHECKSIG",
        "<tx.inputs[0].assets.lookup(priceAssetId)>",
        "0",
        "OP_INSPECTOUTPUTSCRIPTPUBKEY",
        "<new PriceBeacon(priceAssetId, newOraclePk)>",
        "OP_EQUAL",
        "0",
        "<priceAssetId_txid>",
        "<priceAssetId_gidx>",
        "OP_INSPECTOUTASSETLOOKUP",
        "OP_DUP",
        "OP_1NEGATE",
        "OP_EQUAL",
        "OP_NOT",
        "OP_VERIFY",
        "<currentPrice>",
        "OP_EQUAL",
        "OP_VERIFY",
        "<SERVER_KEY>",
        "<serverSig>",
        "OP_CHECKSIG"
      ]
    },
    {
      "name": "migrate",
      "functionInputs": [
        {
          "name": "oracleSig",
          "type": "signature"
        },
        {
          "name": "newOraclePk",
          "type": "pubkey"
        },
        {
          "name": "newOraclePkSig",
          "type": "signature"
        }
      ],
      "serverVariant": false,
      "require": [
        {
          "type": "nOfNMultisig",
          "message": "1-of-1 signatures required (introspection fallback)"
        },
        {
          "type": "older",
          "message": "Exit timelock of 144 blocks"
        }
      ],
      "asm": [
        "<newOraclePk>",
        "<newOraclePkSig>",
        "OP_CHECKSIG",
        "144",
        "OP_CHECKSEQUENCEVERIFY",
        "OP_DROP"
      ]
    }
  ],
  "source": "// Price Beacon Contract\n// On-chain price oracle using asset quantity as price.\n// The quantity of priceAssetId represents BTC/USD price in cents.\n//\n// Example: 10000000 = $100,000.00 per BTC\n//\n// Properties:\n// - Price is publicly visible on-chain\n// - Anyone can read via introspection (tx.inputs[i].assets.lookup)\n// - Passthrough ensures beacon survives every transaction\n// - Only oracle can update the price\n\noptions {\n  server = oraclePk;\n  exit = 144;\n}\n\ncontract PriceBeacon(\n  bytes32 priceAssetId,      // Asset whose quantity = price\n  pubkey oraclePk            // Oracle authorized to update\n) {\n  // Anyone can read price via passthrough\n  // Beacon must survive with same or greater asset quantity\n  function passthrough() {\n    // Preserve the beacon script\n    require(\n      tx.outputs[0].scriptPubKey == new PriceBeacon(priceAssetId, oraclePk),\n      \"beacon script must survive\"\n    );\n\n    // Preserve the price asset (quantity is the price)\n    int currentPrice = tx.inputs[0].assets.lookup(priceAssetId);\n    require(\n      tx.outputs[0].assets.lookup(priceAssetId) >= currentPrice,\n      \"price asset must survive\"\n    );\n  }\n\n  // Oracle updates the price by changing asset quantity\n  function update(signature oracleSig, int newPrice) {\n    require(checkSig(oracleSig, oraclePk), \"invalid oracle signature\");\n    require(newPrice > 0, \"price must be positive\");\n\n    // Preserve the beacon script\n    require(\n      tx.outputs[0].scriptPubKey == new PriceBeacon(priceAssetId, oraclePk),\n      \"beacon script must survive\"\n    );\n\n    // Output must have newPrice as asset quantity\n    require(\n      tx.outputs[0].assets.lookup(priceAssetId) == newPrice,\n      \"price not updated correctly\"\n    );\n  }\n\n  // Oracle can migrate to new beacon (upgrade)\n  function migrate(signature oracleSig, pubkey newOraclePk) {\n    require(checkSig(oracleSig, oraclePk), \"invalid oracle signature\");\n\n    int currentPrice = tx.inputs[0].assets.lookup(priceAssetId);\n\n    // Create new beacon with new oracle\n    require(\n      tx.outputs[0].scriptPubKey == new PriceBeacon(priceAssetId, newOraclePk),\n      \"invalid new beacon\"\n    );\n    require(\n      tx.outputs[0].assets.lookup(priceAssetId) == currentPrice,\n      \"price must be preserved\"\n    );\n  }\n}\n",
  "compiler": {
    "name": "arkade-compiler",
    "version": "0.1.0"
  },
  "updatedAt": "2026-02-10T22:23:26.621436+00:00"
}